<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Souyette Card Game Pocket</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif; /* Utilisation de la police Inter */
            margin: 0;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 1.5rem;
            position: relative;
            border-bottom-left-radius: 10px; /* Coins arrondis */
            border-bottom-right-radius: 10px; /* Coins arrondis */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Ombre douce */
        }
        #logout-btn {
            position: absolute;
            right: 1rem;
            top: 1rem;
            background: #c0392b;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 8px; /* Coins plus arrondis */
            cursor: pointer;
            font-size: 0.9rem;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease;
        }
        #logout-btn:hover {
            background: #e74c3c;
        }
        .tabs {
            display: flex;
            justify-content: center;
            background: #ecf0f1;
            padding: 0.5rem;
            border-bottom: 1px solid #bdc3c7;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .tab-btn {
            padding: 0.7rem 1.2rem; /* Plus de padding */
            margin: 0 0.5rem;
            border: none;
            border-radius: 8px; /* Coins plus arrondis */
            background: #bdc3c7;
            color: #333;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease, color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .tab-btn:hover {
            background: #aab0b4;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #3498db;
            color: white;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }
        main {
            padding: 1.5rem; /* Plus de padding */
            max-width: 900px; /* Légèrement plus large */
            margin: 1.5rem auto; /* Marge autour */
            flex-grow: 1; /* Permet à main de prendre l'espace disponible */
            background: white;
            border-radius: 12px; /* Coins arrondis */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* Ombre plus prononcée */
        }
        .booster-btn, #buy-shop-card-btn {
            background: #e67e22;
            color: white;
            border: none;
            padding: 1rem;
            font-size: 1.1rem;
            border-radius: 10px;
            margin: 0.5rem 0;
            cursor: pointer;
            width: 100%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease;
        }
        .booster-btn:hover, #buy-shop-card-btn:hover {
            background: #d35400;
            transform: translateY(-2px);
        }
        .booster-btn:disabled, #buy-shop-card-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .booster-buttons-container {
            display: flex; /* Utilise Flexbox pour aligner les éléments sur une seule ligne */
            justify-content: center; /* Centre les images horizontalement dans le conteneur */
            align-items: flex-start; /* Aligne les éléments en haut (si leurs tailles varient) */
            gap: 15px; /* Ajoute un espace de 15px entre les images */
            flex-wrap: wrap; /* Permet aux images de passer à la ligne si l'écran est trop petit */
            margin-top: 1rem;
            margin-bottom: 1rem;
            max-width: 90vw;
            margin-left: auto;
            margin-right: auto;
            padding-left: 15px;
            padding-right:15px;
            box-sizing: border-box;
        }

        .booster-image-btn {
            width: 30%; /* Chaque image prendra environ 30% de la largeur du conteneur */
            max-width: 150px; /* Limite la largeur maximale pour éviter des images trop grandes */
            height: auto; /* Maintient les proportions de l'image */
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .booster-image-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        /* Effet brillant pour les cartes */
        .card.shiny-card {
            position: relative;
            overflow: hidden;
        }
        .card.shiny-card::before {
            content: '';
            position: absolute;
            top: -50%; /* Commence le reflet en dehors de la carte */
            left: -50%;
            width: 200%; /* Largeur du reflet */
            height: 200%; /* Hauteur du reflet */
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 200, 200, 0.1) 10%, /* Rendu plus transparent et commencé un peu plus tôt */
                rgba(200, 200, 255, 0.3) 20%, /* Opacité réduite */
                rgba(200, 255, 200, 0.5) 35%, /* Opacité réduite */
                rgba(200, 255, 255, 0.8) 50%, /* Point le plus lumineux (inchangé pour le pic) */
                rgba(200, 150, 150, 0.5) 65%, /* Opacité réduite */
                rgba(150, 255, 150, 0.3) 80%, /* Opacité réduite */
                rgba(255, 255, 255, 0.1) 90%, /* Ajout d'une lueur très faible plus loin */
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(45deg); /* Incline le reflet */
            animation: shiny-sweep 2s infinite cubic-bezier(0.25, 0.1, 0.25, 1); /* Anime le reflet */
            pointer-events: none; /* Permet les interactions avec la carte sous le reflet */
        }

        @keyframes shiny-sweep {
            0% { transform: rotate(45deg) translate(-100%, -100%); opacity: 0; }
            10% { opacity: 1; } /* Apparaît rapidement */
            90% { opacity: 0.8; } /* Reste visible pendant le balayage */
            100% { transform: rotate(45deg) translate(100%, 100%); opacity: 0; } /* Disparaît */
        }
        .card.shiny-card:hover {
            transform: translateY(-5px) scale(1.02); /* Effet au survol de la carte */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* Vous pouvez conserver une ombre au survol si vous voulez */
        }
    
        .card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.2rem; /* Espace plus grand entre les cartes */
            justify-content: center;
            margin-top: 1.5rem;
        }
        .card {
            width: 100px;
            height: 140px;
            border-radius: 10px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Ombre plus douce */
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border 0.2s ease;
            overflow: hidden; /* Pour que l'étoile ne dépasse pas */
        }
        .card:hover {
            transform: translateY(-5px) scale(1.02); /* Effet au survol */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .count-badge {
            position: absolute;
            bottom: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            pointer-events: none; /* Ne bloque pas les clics sur la carte */
        }
        .section {
            display: none;
        }
        .visible {
            display: block;
        }
        #login {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 3rem; /* Plus de padding */
            max-width: 400px;
            margin: 5rem auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }
        #login h2 {
            color: #2c3e50;
            margin-bottom: 1.5rem;
        }
        #login p {
            text-align: center;
            margin-bottom: 1.5rem;
            color: #e74c3c;
            font-weight: bold;
        }
        #login input {
            font-size: 1.3rem; /* Plus grande taille */
            padding: 0.8rem; /* Plus de padding */
            width: 180px; /* Plus large */
            text-align: center;
            margin-bottom: 1.5rem;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease;
        }
        #login input:focus {
            border-color: #3498db;
        }
        #login button {
            font-size: 1.2rem; /* Plus grande taille */
            padding: 0.8rem 1.5rem; /* Plus de padding */
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease;
        }
        #login button:hover {
            background: #229a53;
            transform: translateY(-2px);
        }
        /* Carte agrandie lors de l'ouverture du booster et pour les overlays */
        #booster-preview-overlay, .overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.8); /* Fond plus sombre */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
            animation: fadeIn 0.3s ease-out; /* Animation d'apparition */
        }
        #booster-preview-overlay .card, .overlay .card.expanded {
            width: 300px;
            height: 420px;
            border-radius: 15px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 12px 30px rgba(0,0,0,0.8); /* Ombre plus forte */
            cursor: pointer;
            transform-origin: center center;
            transform: none;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            animation: cardPop 0.4s ease-out; /* Animation d'apparition de la carte */
        }
        #booster-preview-overlay .count-badge, .overlay .count-badge {
            bottom: 10px;
            right: 10px;
            font-size: 1.2rem;
            padding: 6px 10px;
            border-radius: 12px;
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
        }
        #last-booster-summary {
            margin-top: 2rem; /* Plus de marge */
            text-align: center;
            padding: 1.5rem;
            background: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        #last-booster-summary h4 {
            margin-bottom: 1rem;
            color: #34495e;
        }
        #last-booster-summary .card-container .card {
            width: 100px;
            height: 140px;
            position: relative;
            transform: scale(1);
            cursor: default;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        .star-emoji {
            position: absolute;
            bottom: 2px; /* Ajusté pour être dans la carte */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: gold;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(255, 223, 0, 0.8); /* Ombre pour l'étoile */
        }
        /* Style pour la boutique */
        #shop-message {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: #34495e;
            font-weight: bold;
        }
        #daily-shop-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem; /* Plus d'espace */
            justify-content: center;
            margin-bottom: 2rem;
            min-height: 160px; /* Pour éviter le CLS quand les cartes se chargent */
        }
        #daily-shop-cards .card {
            border: 3px solid transparent; /* Bordure par défaut */
        }
        #daily-shop-cards .card.selected-for-purchase {
            border: 3px solid #3498db; /* Bordure pour carte sélectionnée à acheter */
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
            transform: scale(1.05);
        }
        #daily-shop-cards .card .star-emoji {
            /* Positionnement de l'étoile pour la boutique */
            bottom: -20px; /* En dehors de la carte */
        }
        #duplicate-selection-area h5 {
            text-align: center;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #34495e;
            font-size: 1.1rem;
        }
        #duplicate-selection-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            max-height: 300px; /* Limite la hauteur et ajoute un scroll si nécessaire */
            overflow-y: auto;
            padding-bottom: 10px;
        }
        #duplicate-selection-container .card {
            border: 3px solid transparent; /* Bordure par défaut */
        }
        #duplicate-selection-container .card.selected-duplicate {
            border: 3px solid #f1c40f; /* Bordure pour doublon sélectionné */
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            transform: scale(1.05);
        }
        /* Message box pour alert() */
        #message-box-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #message-box {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            text-align: center;
            max-width: 80%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        #message-box-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        #message-box-overlay.visible #message-box {
            transform: translateY(0);
        }
        #message-box p {
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 1.5rem;
        }
        #message-box button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s ease;
        }
        #message-box button:hover {
            background: #2980b9;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes cardPop {
            0% { transform: scale(0.5); opacity: 0; }
            80% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <header>
        Souyette Card Game Pocket
        <button id="logout-btn" onclick="logout()">Déconnexion</button>
    </header>

    <div id="login" class="section visible">
        <h2>Entrez votre code à 6 chiffres</h2>
        <p>⚠️ Soyez bien sur votre navigateur personnel, les comptes sont hébergés en LOCAL. Ne supprimez pas l'historique non plus. ⚠️</p>
        <input type="text" id="codeInput" maxlength="6" placeholder="Ex: 123456" />
        <button onclick="login()">Connexion</button>
    </div>

    <div id="app" style="display: none;">
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('booster')">Booster</button>
            <button class="tab-btn" onclick="switchTab('collection')">Collection</button>
            <button class="tab-btn" onclick="switchTab('shop')">Boutique</button>
        </div>
        <div style="text-align:center; margin: 1rem 0;">
            <button onclick="exportData()" style="margin-right: 1rem;">📤 Exporter mes données</button>
            <label for="importFile" style="cursor: pointer; color: #2980b9; text-decoration: underline;">
            📥 Importer mes données
            </label>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importDataFromFile(this.files[0])">
        </div>
        <main>
        <section id="booster" class="section visible">
            <p>Boosters restants aujourd'hui : <span id="booster-count">3</span></p>
            <p>🔔 N'oubliez pas d'ajouter un rappel à 00h sur votre téléphone pour penser à ouvrir vos boosters !</p>
            <img src="images/booster_OG.jpg" alt="Ouvrir un booster Extension OG" class="booster-image-btn" onclick="openBooster('OG')">
            <img src="images/booster_PR.jpg" alt="Ouvrir un booster Extension PR" class="booster-image-btn" onclick="openBooster('PR')">
            <img src="images/booster_TE.jpg" alt="Ouvrir un booster Extension TE" class="booster-image-btn" onclick="openBooster('TE')">
            <div id="booster-result" class="card-container"></div>

            <div id="last-booster-summary" style="display:none;">
                <h4>Résumé du dernier booster</h4>
                <div class="card-container" id="last-booster-cards"></div>
            </div>
        </section>

            <section id="collection" class="section">
                <h3>Votre Collection</h3>
                <div id="collection-extensions"></div>
            </section>

            <section id="shop" class="section">
                <h3>Boutique</h3>
                <p id="shop-message"></p>
                <div id="daily-shop-cards" class="card-container">
                    </div>
                <button id="buy-shop-card-btn" disabled>Acheter la carte sélectionnée</button>

                <div id="duplicate-selection-area">
                    <h5>Sélectionnez 5 doublons différents pour l'échange :</h5>
                    <div id="duplicate-selection-container" class="card-container">
                        </div>
                </div>
            </section>
        </main>
    </div>

    <div id="booster-preview-overlay" style="display:none;"></div>
    <div id="full-card-overlay" class="overlay" style="display:none;"></div>

    <div id="message-box-overlay">
        <div id="message-box">
            <p id="message-box-text"></p>
            <button id="message-box-ok-btn">OK</button>
        </div>
    </div>

    <script>
        // Constantes du jeu
        const CARDS_PER_BOOSTER = 5;
        const DAILY_BOOSTER_LIMIT = 3;
        const SHOP_DAILY_CARD_COUNT = 5; // Nombre de cartes proposées chaque jour à la boutique
        const SHOP_NEW_CARD_CHANCE = 0.3; // 30% de chance d'avoir une carte non possédée
        const SHOP_TRADE_COST = 5; // Nombre de doublons requis pour un échange

        // Date du jour pour réinitialisations
        const today = new Date().toDateString();
        let currentCode = ""; // Code utilisateur actuel

        // Structure des extensions et des chemins d'images
        const extensions = {
            OG: Array.from({ length: 125 }, (_, i) => `images/OG/${String(i + 1).padStart(3, '0')}.jpg`),
            PR: Array.from({ length: 65 }, (_, i) => `images/PR/${String(i + 1).padStart(3, '0')}.jpg`),
            TE: Array.from({ length: 65 }, (_, i) => `images/TE/${String(i + 1).padStart(3, '0')}.jpg`),
        };

        // Liste des chemins d'images des cartes brillantes
        const SHINY_CARDS_PATHS = [];

        // images/OG/120.jpg à 125.jpg
        for (let i = 121; i <= 125; i++) {
            SHINY_CARDS_PATHS.push(`images/OG/${String(i).padStart(3, '0')}.jpg`);
        }

        // images/PR/035.jpg
            SHINY_CARDS_PATHS.push("images/PR/035.jpg");

        // images/PR/062.jpg à 065.jpg
        for (let i = 62; i <= 65; i++) {
            SHINY_CARDS_PATHS.push(`images/PR/${String(i).padStart(3, '0')}.jpg`);
        }

        // images/TE/064.jpg à 065.jpg
        for (let i = 64; i <= 65; i++) {
            SHINY_CARDS_PATHS.push(`images/TE/${String(i).padStart(3, '0')}.jpg`);
        }

        // Références aux éléments DOM
        const loginSection = document.getElementById("login");
        const appSection = document.getElementById("app");
        const codeInput = document.getElementById("codeInput");
        const boosterCountSpan = document.getElementById("booster-count");
        const boosterResultContainer = document.getElementById("booster-result");
        const lastBoosterSummary = document.getElementById("last-booster-summary");
        const lastBoosterCardsContainer = document.getElementById("last-booster-cards");
        const collectionExtensionsContainer = document.getElementById("collection-extensions");
        const boosterPreviewOverlay = document.getElementById("booster-preview-overlay");
        const fullCardOverlay = document.getElementById("full-card-overlay");
        const messageBoxOverlay = document.getElementById("message-box-overlay");
        const messageBoxText = document.getElementById("message-box-text");
        const messageBoxOkBtn = document.getElementById("message-box-ok-btn");
        const logoutBtn = document.getElementById("logout-btn"); // Ajouté car son onclick est dans le HTML

        // Boutique éléments
        const shopSection = document.getElementById("shop");
        const shopMessage = document.getElementById("shop-message");
        const dailyShopCardsContainer = document.getElementById("daily-shop-cards");
        const buyShopCardBtn = document.getElementById("buy-shop-card-btn");
        const duplicateSelectionArea = document.getElementById("duplicate-selection-area");
        const duplicateSelectionContainer = document.getElementById("duplicate-selection-container");


        // Variables d'état du jeu (pour l'ouverture de booster)
        let boosterCardsToShow = [];
        let boosterCardIndex = 0;

        /**
         * @typedef {Object} CardData
         * @property {string} image - Chemin de l'image de la carte.
         * @property {string} extension - Extension de la carte (ex: 'OG', 'PR', 'TE').
         * @property {number} count - Nombre d'exemplaires de cette carte possédés.
         * @property {boolean} [isNew] - Indique si la carte est nouvelle (utilisé pour les boosters/boutique).
         * @property {boolean} [isSelectedForPurchase] - Indique si la carte de la boutique est sélectionnée pour achat.
         * @property {boolean} [isSelectedAsDuplicate] - Indique si la carte est sélectionnée comme doublon pour un échange.
         */

        /**
         * Affiche un message à l'utilisateur dans une boîte de dialogue personnalisée.
         * Remplace les alert().
         * @param {string} message - Le message à afficher.
         */
        function showMessage(message) {
            messageBoxText.textContent = message;
            messageBoxOverlay.classList.add("visible");
        }

        /**
         * Retourne la clé de stockage unique pour l'utilisateur actuel.
         * @returns {string} La clé localStorage.
         */
        function getStorageKey() {
            return `cardData_user_${currentCode}`;
        }

        /**
         * Récupère les données du jeu depuis localStorage pour l'utilisateur actuel.
         * Initialise les données si elles n'existent pas ou sont obsolètes (jour précédent).
         * @returns {Object} Les données du jeu.
         */
        function getData() {
            let data = JSON.parse(localStorage.getItem(getStorageKey())) || {};

            // Réinitialisation quotidienne des boosters et de la boutique
            if (data.date !== today) {
                data.date = today;
                data.remaining = DAILY_BOOSTER_LIMIT;
                data.shopBoughtToday = false; // Réinitialise l'achat de la boutique
                data.shopDate = today; // Met à jour la date de la boutique
                data.shopCards = generateShopCardsInternal(data.collection || []); // Génère de nouvelles cartes pour la boutique
            }

            data.collection = data.collection || [];
            data.lastBooster = data.lastBooster || null;
            // Assure que les cartes boutique sont toujours là (pour les cas où data.date était déjà 'today' mais shopCards manquait)
            if (!data.shopCards || data.shopDate !== today) {
                 data.shopCards = generateShopCardsInternal(data.collection);
                 data.shopDate = today;
            }
            data.shopBoughtToday = data.shopBoughtToday || false;
            data.selectedShopCard = data.selectedShopCard === undefined ? null : data.selectedShopCard;
            data.selectedDuplicatesForShop = data.selectedDuplicatesForShop || [];


            saveData(data); // Sauvegarde les données initialisées ou mises à jour
            return data;
        }

        /**
         * Sauvegarde les données du jeu dans localStorage pour l'utilisateur actuel.
         * @param {Object} data - Les données du jeu à sauvegarder.
         */
        function saveData(data) {
            localStorage.setItem(getStorageKey(), JSON.stringify(data));
        }

        /**
         * Met à jour le compteur de boosters restants affiché.
         */
        function updateBoosterCount() {
            const data = getData();
            document.getElementById("booster-count").textContent = data.remaining;
        }

        /**
         * Ouvre un booster d'une extension donnée.
         * Reprise de la logique de index (4).html
         * @param {string} extension - L'extension du booster ('OG' ou 'PR').
         */
        function openBooster(extension) {
            const data = getData();
            if (data.remaining <= 0) {
                showMessage("Vous avez atteint la limite de boosters pour aujourd'hui !");
                return;
            }

            const pool = extensions[extension];
            boosterCardsToShow = [];
            boosterCardIndex = 0;

            // Tirage aléatoire de cartes
            for (let i = 0; i < CARDS_PER_BOOSTER; i++) {
                const image = pool[Math.floor(Math.random() * pool.length)];
                boosterCardsToShow.push({ image, extension, isNew: false });
            }

            // Détection des nouvelles cartes
            boosterCardsToShow.forEach(card => {
                const existing = data.collection.find(c => c.image === card.image && c.extension === card.extension);
                card.isNew = !existing;
            });

            // Mise à jour collection (incrémente count si déjà présent)
            boosterCardsToShow.forEach(card => {
                const existing = data.collection.find(c => c.image === card.image && c.extension === card.extension);
                if (existing) {
                    existing.count = (existing.count || 1) + 1;
                } else {
                    data.collection.push({ image: card.image, extension: card.extension, count: 1 });
                }
            });

            data.remaining--;
            data.lastBooster = boosterCardsToShow.map(c => ({...c})); // clone
            saveData(data);
            updateBoosterCount();

            showBoosterPreview();

            // Cacher résumé dernier booster
            document.getElementById("last-booster-summary").style.display = "none";
            updateCollection();
        }

        /**
         * Affiche l'animation d'ouverture de booster carte par carte.
         * Reprise de la logique de index (4).html
         */
        function showBoosterPreview() {
            const overlay = document.getElementById("booster-preview-overlay");
            overlay.innerHTML = "";
            overlay.style.display = "flex";

            let idx = 0;

            function showCard(i) {
                overlay.innerHTML = "";
                const card = boosterCardsToShow[i];
                if (!card) return;

                const el = document.createElement("div");
                el.className = "card";
                el.style.backgroundImage = `url(${card.image})`;
                if (SHINY_CARDS_PATHS.includes(card.image)) {
                    el.classList.add("shiny-card");
                }
                if (card.isNew) {
                    const star = document.createElement("div");
                    star.textContent = "⭐";
                    star.className = "star-emoji";
                    el.appendChild(star);
                }
                overlay.appendChild(el);

                el.onclick = () => {
                    idx++;
                    if (idx < boosterCardsToShow.length) {
                        showCard(idx);
                    } else {
                        overlay.style.display = "none";
                        // Afficher les cartes dans le conteneur principal du booster une fois l'animation terminée
                        displayBoosterResultCards(boosterCardsToShow);
                        showLastBoosterSummary();
                    }
                };
            }

            showCard(0);
        }

        /**
         * NOUVELLE FONCTION: Affiche les cartes du booster dans le conteneur principal de résultat.
         * @param {Array<CardData>} cards - Les cartes à afficher.
         */
        function displayBoosterResultCards(cards) {
            boosterResultContainer.innerHTML = ""; // Vider le container avant d'ajouter les cartes
            cards.forEach(card => {
                const el = document.createElement("div");
                el.className = "card";
                el.style.backgroundImage = `url(${card.image})`;
                if (SHINY_CARDS_PATHS.includes(card.image)) {
                    el.classList.add("shiny-card");
                }
                if (card.isNew) {
                    const star = document.createElement("div");
                    star.textContent = "⭐";
                    star.className = "star-emoji";
                    el.appendChild(star);
                }
                boosterResultContainer.appendChild(el);
            });
            boosterResultContainer.style.display = "flex"; // S'assurer que le container est visible
        }

        /**
         * Affiche le résumé des cartes obtenues lors du dernier booster ouvert.
         * Reprise de la logique de index (4).html
         */
        function showLastBoosterSummary() {
            const data = getData();
            const summary = document.getElementById("last-booster-summary");
            const container = document.getElementById("last-booster-cards");
            container.innerHTML = "";

            if (!data.lastBooster || data.lastBooster.length === 0) {
                summary.style.display = "none";
                return;
            }

            data.lastBooster.forEach(card => {
                const el = document.createElement("div");
                el.className = "card";
                el.style.backgroundImage = `url(${card.image})`;
                if (SHINY_CARDS_PATHS.includes(card.image)) {
                   cardEl.classList.add("shiny-card");
                }
                if (card.isNew) {
                    const star = document.createElement("div");
                    star.textContent = "⭐";
                    star.className = "star-emoji";
                    el.appendChild(star);
                }
                container.appendChild(el);
            });

            summary.style.display = "block";
        }

        /**
         * Met à jour l'affichage de la collection de cartes par extension.
         * Reprise de la logique de index (4).html
         */
        function updateCollection() {
            const data = getData();
            const container = document.getElementById("collection-extensions");
            container.innerHTML = "";

            // Organiser par extension
            const collectionsByExtension = {};
            data.collection.forEach(card => {
                if (!collectionsByExtension[card.extension]) {
                    collectionsByExtension[card.extension] = [];
                }
                collectionsByExtension[card.extension].push(card);
            });

            for (const ext in collectionsByExtension) {
                // Trier les cartes par numéro de fichier
                const cards = collectionsByExtension[ext].sort((a, b) => {
                    const getNumber = img => parseInt(img.image.match(/(\d+)\.jpg$/)[1], 10);
                    return getNumber(a) - getNumber(b);
                });

                const totalAvailable = ext === "OG" ? extensions.OG.length : ext === "PR" ? extensions.PR.length : ext === "TE" ? extensions.TE.length : 0;
                const ownedUnique = new Set(cards.map(c => c.image)).size;

                const extSection = document.createElement("div");
                extSection.innerHTML = `<h4>Extension ${ext} (${ownedUnique}/${totalAvailable})</h4>`;

                const cardsDiv = document.createElement("div");
                cardsDiv.className = "card-container";

                cards.forEach(card => {
                    const cardDiv = document.createElement("div");
                    cardDiv.className = "card";
                    cardDiv.style.backgroundImage = `url(${card.image})`;
                    if (SHINY_CARDS_PATHS.includes(card.image)) {
                        cardDiv.classList.add("shiny-card");
                    }

                    if (card.count > 1) {
                        const countBadge = document.createElement("div");
                        countBadge.className = "count-badge";
                        countBadge.textContent = `x${card.count}`;
                        cardDiv.appendChild(countBadge);
                    }

                    // Agrandir carte au clic
                    cardDiv.addEventListener("click", () => {
                        showFullCardOverlay(card.image, card.count);
                    });

                    cardsDiv.appendChild(cardDiv);
                });

                extSection.appendChild(cardsDiv);
                container.appendChild(extSection);
            }
        }

        /**
         * Affiche un overlay pour agrandir une carte (utilisé pour la collection et la boutique).
         * Reprise de la logique de index (4).html
         * @param {string} image - Chemin de l'image de la carte.
         * @param {number} count - Nombre d'exemplaires de cette carte.
         */
        function showFullCardOverlay(image, count) {
            fullCardOverlay.innerHTML = ""; // Nettoie l'overlay précédent
            fullCardOverlay.style.display = "flex";

            const card = document.createElement("div");
            card.className = "card expanded";
            card.style.backgroundImage = `url(${image})`;
            if (SHINY_CARDS_PATHS.includes(image)) {
                card.classList.add("shiny-card");
            } else {
                // IMPORTANT: Si la carte n'est PAS brillante, assurez-vous de retirer la classe.
                // C'est crucial car l'overlay est réutilisé.
                card.classList.remove("shiny-card");
            }
            if (count !== undefined && count > 1) { // Affiche le count badge si présent et > 1
                const countBadge = document.createElement("div");
                countBadge.className = "count-badge";
                countBadge.textContent = `x${count}`;
                card.appendChild(countBadge);
            }

            fullCardOverlay.appendChild(card);

            // Ferme l'overlay au clic n'importe où dessus
            fullCardOverlay.onclick = () => {
                fullCardOverlay.style.display = "none";
            };
        }

        /**
         * Génère les 5 cartes quotidiennes pour la boutique.
         * 30% de chance d'être une carte non possédée.
         * @param {Array<CardData>} userCollection - La collection actuelle de l'utilisateur.
         * @returns {Array<CardData>} Les 5 cartes de la boutique pour le jour.
         */
        function generateShopCardsInternal(userCollection) {
            const allPossibleCards = [];
            // Cette boucle itère sur 'OG' et 'PR'
            for (const ext in extensions) {
                extensions[ext].forEach(image => {
                    // Ajoute les cartes des deux extensions à la liste de toutes les cartes possibles
                    allPossibleCards.push({ image, extension: ext });
                });
            }

            const unownedCards = allPossibleCards.filter(card =>
                !userCollection.some(c => c.image === card.image && c.extension === card.extension)
            );
            const ownedCards = allPossibleCards.filter(card =>
                userCollection.some(c => c.image === card.image && c.extension === card.extension)
            );

            const dailyCards = [];
            for (let i = 0; i < SHOP_DAILY_CARD_COUNT; i++) {
                let chosenCard;
                const isNewChance = Math.random();

                // 30% de chance d'obtenir une nouvelle carte si des nouvelles sont disponibles
                if (isNewChance < SHOP_NEW_CARD_CHANCE && unownedCards.length > 0) {
                    chosenCard = unownedCards[Math.floor(Math.random() * unownedCards.length)];
                    // Pour éviter de proposer la même carte non possédée plusieurs fois dans la même sélection journalière
                    unownedCards.splice(unownedCards.indexOf(chosenCard), 1);
                } else {
                    // Sinon, tire au hasard parmi toutes les cartes possibles
                    chosenCard = allPossibleCards[Math.floor(Math.random() * allPossibleCards.length)];
                }

                // Vérifie si la carte choisie est déjà possédée par l'utilisateur
                const isOwned = userCollection.some(c => c.image === chosenCard.image && c.extension === chosenCard.extension);
                dailyCards.push({ ...chosenCard, isNew: !isOwned, isSelectedForPurchase: false });
            }
            return dailyCards;
        }

        /**
         * Met à jour l'affichage de la boutique.
         */
        function updateShop() {
            const data = getData(); // S'assure que les données sont à jour (y compris shopDate et shopCards)

            dailyShopCardsContainer.innerHTML = "";
            duplicateSelectionContainer.innerHTML = "";
            duplicateSelectionArea.style.display = "block"; // Affiche toujours l'aire de sélection par défaut

            if (data.shopBoughtToday) {
                shopMessage.textContent = "💰 Revenez demain pour un nouvel achat !";
                dailyShopCardsContainer.style.display = "none";
                buyShopCardBtn.style.display = "none";
                duplicateSelectionArea.style.display = "none"; // Cache l'aire de sélection si déjà acheté
                return;
            } else {
                shopMessage.textContent = ""; // Réinitialise le message
                dailyShopCardsContainer.style.display = "flex";
                buyShopCardBtn.style.display = "block";
            }

            // Affiche les 5 cartes du jour dans la boutique
            data.shopCards.forEach((card, index) => {
                const cardDiv = document.createElement("div");
                // La classe 'selected-for-purchase' est appliquée si la carte correspond à la carte sélectionnée
                // et si son index correspond à data.selectedShopCard
                const isSelected = data.selectedShopCard !== null && data.selectedShopCard === index;
                cardDiv.className = `card ${isSelected ? 'selected-for-purchase' : ''}`;
                cardDiv.style.backgroundImage = `url(${card.image})`;
                if (SHINY_CARDS_PATHS.includes(card.image)) {
                    cardEl.classList.add("shiny-card");
                }
                if (card.isNew) {
                    const star = document.createElement("div");
                    star.textContent = "⭐";
                    star.className = "star-emoji";
                    cardDiv.appendChild(star);
                }

                // Gère la sélection d'une carte à acheter dans la boutique
                cardDiv.addEventListener("click", () => {
                    selectShopCard(index);
                });
                dailyShopCardsContainer.appendChild(cardDiv);
            });

            // Active/Désactive le bouton d'achat
            updateBuyButtonState();
            // Affiche les doublons disponibles pour l'échange
            renderDuplicatesForSelection();
        }

        /**
         * Sélectionne une carte dans la boutique pour l'achat.
         * @param {number} index - L'index de la carte sélectionnée dans le tableau shopCards.
         */
        function selectShopCard(index) {
            const data = getData();
            // Si la carte est déjà sélectionnée, la désélectionne
            if (data.selectedShopCard === index) {
                data.selectedShopCard = null;
            } else {
                // Sinon, sélectionne cette carte
                data.selectedShopCard = index;
            }
            saveData(data);
            updateShop(); // Rafraîchit l'affichage pour montrer la sélection
        }

        /**
         * Rend les cartes doublons de l'utilisateur pour la sélection.
         */
        function renderDuplicatesForSelection() {
            const data = getData();
            duplicateSelectionContainer.innerHTML = "";

            // Filtre les cartes qui ont plus d'un exemplaire (ce sont les doublons échangeables)
            const availableDuplicates = data.collection.filter(card => card.count > 1);

            if (availableDuplicates.length === 0) {
                duplicateSelectionArea.innerHTML = "<h5>Vous n'avez pas de doublons à échanger.</h5>";
                buyShopCardBtn.disabled = true;
                return;
            }

            // Trie les doublons pour un affichage cohérent
            availableDuplicates.sort((a, b) => {
                const getNumber = img => parseInt(img.image.match(/(\d+)\.jpg$/)[1], 10);
                if (a.extension === b.extension) {
                    return getNumber(a) - getNumber(b);
                }
                return a.extension.localeCompare(b.extension);
            });


            availableDuplicates.forEach(card => {
                const cardDiv = document.createElement("div");
                // Vérifie si la carte est actuellement sélectionnée comme doublon
                const isSelected = data.selectedDuplicatesForShop.some(
                    selCard => selCard.image === card.image && selCard.extension === card.extension
                );
                cardDiv.className = `card ${isSelected ? 'selected-duplicate' : ''}`;
                cardDiv.style.backgroundImage = `url(${card.image})`;
                 if (SHINY_CARDS_PATHS.includes(card.image)) {
                    cardDiv.classList.add("shiny-card");
                }
                // Calcule le nombre de doublons disponibles pour cette carte (total - 1)
                const countBadge = document.createElement("div");
                countBadge.className = "count-badge";
                countBadge.textContent = `x${card.count - 1}`;
                cardDiv.appendChild(countBadge);

                // Ajoute l'écouteur de clic pour sélectionner/désélectionner le doublon
                cardDiv.addEventListener("click", () => {
                    toggleDuplicateSelection(card);
                });
                duplicateSelectionContainer.appendChild(cardDiv);
            });
            updateBuyButtonState(); // Ensure this is called
        }

        /**
         * Ajoute ou retire une carte des doublons sélectionnés pour l'échange.
         * @param {Object} cardToToggle - La carte à sélectionner/désélectionner (doit avoir image et extension).
         */
        function toggleDuplicateSelection(cardToToggle) {
            const data = getData();
            // Créer un objet simple avec juste les propriétés nécessaires pour l'identification
            const identifyingCard = { image: cardToToggle.image, extension: cardToToggle.extension };

            const index = data.selectedDuplicatesForShop.findIndex(
                selCard => selCard.image === identifyingCard.image && selCard.extension === identifyingCard.extension
            );

            if (index > -1) {
                // La carte est déjà sélectionnée, la désélectionne
                data.selectedDuplicatesForShop.splice(index, 1);
            } else {
                // La carte n'est pas sélectionnée, l'ajoute si la limite n'est pas atteinte
                if (data.selectedDuplicatesForShop.length < SHOP_TRADE_COST) {
                    data.selectedDuplicatesForShop.push(identifyingCard); // Ajoute l'objet simplifié
                } else {
                    showMessage(`Vous ne pouvez sélectionner que ${SHOP_TRADE_COST} doublons différents.`);
                }
            }
            saveData(data);
            renderDuplicatesForSelection(); // Rafraîchit l'affichage des doublons, qui appellera updateBuyButtonState()
        }

        /**
         * Met à jour l'état du bouton d'achat de la boutique (activé/désactivé).
         */
        function updateBuyButtonState() {
            const data = getData();
            const isShopCardSelected = data.selectedShopCard !== null;
            const hasEnoughDuplicates = data.selectedDuplicatesForShop.length === SHOP_TRADE_COST;
            const canBuy = isShopCardSelected && hasEnoughDuplicates && !data.shopBoughtToday;

            buyShopCardBtn.disabled = !canBuy;

            // Met à jour le texte du bouton si une carte est sélectionnée
            if (isShopCardSelected && data.shopCards[data.selectedShopCard]) { // Ajout d'une vérification pour s'assurer que la carte est bien définie
                const cardName = data.shopCards[data.selectedShopCard].image.split('/').pop().split('.')[0];
                buyShopCardBtn.textContent = `Acheter "${cardName}" (${data.selectedDuplicatesForShop.length}/${SHOP_TRADE_COST} doublons)`;
            } else {
                buyShopCardBtn.textContent = `Acheter la carte sélectionnée (${data.selectedDuplicatesForShop.length}/${SHOP_TRADE_COST} doublons)`;
            }
        }

        /**
         * Gère l'achat d'une carte dans la boutique.
         */
        function buyShopCard() {
            const data = getData();

            // Vérifications supplémentaires pour la sécurité
            if (data.shopBoughtToday) {
                showMessage("Vous avez déjà effectué un achat dans la boutique aujourd'hui. Revenez demain !");
                return;
            }
            if (data.selectedShopCard === null) {
                showMessage("Veuillez sélectionner une carte à acheter dans la boutique.");
                return;
            }
            if (data.selectedDuplicatesForShop.length !== SHOP_TRADE_COST) {
                showMessage(`Veuillez sélectionner ${SHOP_TRADE_COST} doublons différents pour l'échange.`);
                return;
            }

            const cardToBuy = data.shopCards[data.selectedShopCard];

            // Déduit les doublons de la collection
            data.selectedDuplicatesForShop.forEach(selDup => {
                const existingCard = data.collection.find(
                    c => c.image === selDup.image && c.extension === selDup.extension
                );
                if (existingCard && existingCard.count > 1) {
                    existingCard.count--; // Réduit le compte d'un exemplaire
                } else {
                    // Ce cas ne devrait pas arriver si la sélection est bien gérée,
                    // mais c'est une sécurité.
                    console.error("Doublon sélectionné introuvable ou pas en quantité suffisante:", selDup);
                }
            });

            // Ajoute la carte achetée à la collection
            const existingBoughtCard = data.collection.find(
                c => c.image === cardToBuy.image && c.extension === cardToBuy.extension
            );
            if (existingBoughtCard) {
                existingBoughtCard.count++;
            } else {
                data.collection.push({ image: cardToBuy.image, extension: cardToBuy.extension, count: 1 });
            }

            data.shopBoughtToday = true; // Marque l'achat du jour
            data.selectedShopCard = null; // Réinitialise la sélection
            data.selectedDuplicatesForShop = []; // Réinitialise les doublons sélectionnés

            saveData(data);
            updateBoosterCount(); // Au cas où les boosters sont liés
            updateCollection(); // Met à jour l'affichage de la collection
            updateShop(); // Met à jour l'affichage de la boutique

            // Affiche la carte achetée en grand
            showMessage("Achat réussi !"); // Affiche un message de succès
            // showFullCardOverlay(cardToBuy.image, existingBoughtCard ? existingBoughtCard.count : 1); // Ne pas ouvrir l'overlay auto après le message
        }

        /**
         * Change l'onglet actif.
         * @param {string} tabName - Le nom de l'onglet à activer ('booster', 'collection', 'shop').
         */
        function switchTab(tabName) {
            const sections = document.querySelectorAll(".section");
            sections.forEach(s => s.classList.remove("visible"));

            const tabs = document.querySelectorAll(".tab-btn");
            tabs.forEach(tab => tab.classList.remove("active"));

            switch (tabName) {
                case "booster":
                    document.getElementById("booster").classList.add("visible");
                    // Active le bouton d'onglet "Booster"
                    document.querySelector('.tab-btn[onclick="switchTab(\'booster\')"]').classList.add("active");
                    break;
                case "collection":
                    document.getElementById("collection").classList.add("visible");
                    // Active le bouton d'onglet "Collection"
                    document.querySelector('.tab-btn[onclick="switchTab(\'collection\')"]').classList.add("active");
                    updateCollection(); // Mettre à jour la collection à chaque fois qu'on y va
                    break;
                case "shop":
                    shopSection.classList.add("visible");
                    // Active le bouton d'onglet "Boutique"
                    document.querySelector('.tab-btn[onclick="switchTab(\'shop\')"]').classList.add("active");
                    updateShop(); // Mettre à jour la boutique à chaque fois qu'on y va
                    break;
            }
        }

        /**
         * Gère la connexion de l'utilisateur avec le code à 6 chiffres.
         * Reprise de la logique de index (4).html
         */
        function login() {
            const code = codeInput.value.trim();
            if (!/^\d{6}$/.test(code)) {
                showMessage("Veuillez entrer un code à 6 chiffres valide.");
                return;
            }
            currentCode = code;
            document.getElementById("login").style.display = "none";
            document.getElementById("app").style.display = "block";
            document.getElementById("logout-btn").style.display = "inline-block"; // Afficher le bouton de déconnexion
            updateBoosterCount();
            showLastBoosterSummary();
            updateCollection();
            updateShop(); // S'assure que la boutique est à jour au login
            switchTab('booster'); // Défaut sur l'onglet booster après connexion
        }

        /**
         * Gère la déconnexion de l'utilisateur.
         * Reprise de la logique de index (4).html
         */
        function logout() {
            currentCode = "";
            document.getElementById("login").style.display = "flex";
            document.getElementById("app").style.display = "none";
            document.getElementById("logout-btn").style.display = "none";
            document.getElementById("codeInput").value = ""; // Vide le champ de code
            // Nettoyage des éléments d'interface à la déconnexion
            boosterResultContainer.innerHTML = "";
            lastBoosterSummary.style.display = "none";
            collectionExtensionsContainer.innerHTML = "";
            dailyShopCardsContainer.innerHTML = "";
            shopMessage.textContent = "";
            duplicateSelectionContainer.innerHTML = "";
            buyShopCardBtn.disabled = true;
            buyShopCardBtn.textContent = `Acheter la carte sélectionnée (${0}/${SHOP_TRADE_COST} doublons)`;
        }

        // --- Initialisation des écouteurs d'événements ---
        // Le login et le logout ont des onclick directement dans l'HTML, donc pas besoin d'addEventListener ici.
        // Les boutons booster ont aussi des onclick directement dans l'HTML.

        buyShopCardBtn.addEventListener("click", buyShopCard);

        // Écouteur pour le bouton OK de la boîte de message
        messageBoxOkBtn.addEventListener("click", () => {
            messageBoxOverlay.classList.remove("visible");
        });

        // Initialisation de l'application (afficher la page de login au démarrage)
        window.onload = () => {
            // S'assure que le mode login est visible au chargement de la page
            loginSection.style.display = "flex";
            appSection.style.display = "none";
            logoutBtn.style.display = "none";
        };
function exportData() {
    if (!currentCode) {
        showMessage("Veuillez vous connecter avant d'exporter.");
        return;
    }
    const key = getStorageKey();
    const data = localStorage.getItem(key);
    if (!data) {
        showMessage("Aucune donnée trouvée à exporter.");
        return;
    }

    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `souyette_data_${currentCode}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function importDataFromFile(file) {
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const imported = JSON.parse(event.target.result);
            if (!currentCode) {
                showMessage("Connectez-vous d'abord avant d'importer.");
                return;
            }

            // Vérification minimale
            if (!imported.collection || !imported.date) {
                showMessage("Fichier invalide ou incomplet.");
                return;
            }

            localStorage.setItem(getStorageKey(), JSON.stringify(imported));
            showMessage("Importation réussie !");
            updateBoosterCount();
            updateCollection();
            updateShop();
            showLastBoosterSummary();
        } catch (err) {
            showMessage("Erreur lors de l'importation. Fichier non valide.");
        }
    };
    reader.readAsText(file);
}
    </script>
</body>
</html>

